package llcppg

import (
	"bytes"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/goplus/llpkgstore/actions/generator"
)

var (
	goModFile   = "go.mod"
	canHashFile = map[string]struct{}{
		"llcppg.pub": {},
		"go.mod":     {},
		"go.sum":     {},
	}
	ErrLlcppgGenerate = errors.New("llcppg: cannot generate: ")
	ErrLlcppgCheck    = errors.New("llcppg: check fail: ")
)

const (
	// llcppg default config file, which MUST exist in specifed dir
	llcppgConfigFile = "llcppg.cfg"
)

// canHash check file is hashable.
// Hashable file: *.go / llcppg.pub / *.symb.json
func canHash(fileName string) bool {
	if strings.Contains(fileName, ".go") {
		return true
	}
	_, ok := canHashFile[fileName]
	return ok
}

// hashFile hash a file in SHA-256
func hashFile(filePath string) ([]byte, error) {
	f, err := os.Open(filePath)
	if err != nil {
		return nil,
			fmt.Errorf("cannot open file: %s err: %v", filePath, err)
	}
	defer f.Close()

	h := sha256.New()
	if _, err := io.Copy(h, f); err != nil {
		return nil,
			fmt.Errorf("cannot hash file: %s err: %v", filePath, err)
	}
	return h.Sum(nil), nil
}

// hashDir hash all the hashable file for the specified directory.
func hashDir(dir string) (fileMap map[string][]byte, err error) {
	fileMap = map[string][]byte{}
	// use ReadDir here instead of filepath.Walk to avoid reading files recursively.
	fs, err := os.ReadDir(dir)
	if err != nil {
		return
	}
	for _, file := range fs {
		// only hashable file
		if !file.IsDir() && canHash(file.Name()) {
			path := filepath.Join(dir, file.Name())
			value, err1 := hashFile(path)
			if err1 != nil {
				err = err1
				break
			}
			fileMap[filepath.Base(path)] = value
		}
	}

	return
}

// llcppgGenerator implements Generator interface, which use llcppg tool to generate llpkg.
type llcppgGenerator struct {
	dir string // llcppg.cfg abs path
}

func New(dir string) generator.Generator {
	return &llcppgGenerator{dir: dir}
}

// findGoMod returns the nested go.mod filepath generated by llcppg
func (l *llcppgGenerator) findGoMod() (baseDir string) {
	maxDepth := 0
	filepath.Walk(l.dir, func(path string, info fs.FileInfo, err error) error {
		if !info.IsDir() && info.Name() == goModFile {
			depth := strings.Count(path, string(os.PathSeparator))
			// we want nested go.mod only, so filter it out.
			if depth > maxDepth {
				maxDepth = depth
				baseDir = filepath.Dir(path)
			}
		}
		return nil
	})
	// no nested go.mod found, return empty string
	if baseDir == l.dir {
		baseDir = ""
	}
	return
}

func (l *llcppgGenerator) Generate() error {
	cmd := exec.Command("llcppg", llcppgConfigFile)
	cmd.Dir = l.dir
	ret, err := cmd.CombinedOutput()
	if err != nil {
		return errors.Join(ErrLlcppgGenerate, errors.New(string(ret)))
	}
	return nil
}

func (l *llcppgGenerator) Check() error {
	// 1. find generated dir
	baseDir := l.findGoMod()
	if baseDir == "" {
		return errors.Join(ErrLlcppgCheck, errors.New("generated llpkg is not found"))
	}
	// 2. compute hash
	generated, err := hashDir(baseDir)
	if err != nil {
		return errors.Join(ErrLlcppgCheck, err)
	}
	userGenerated, err := hashDir(l.dir)
	if err != nil {
		return errors.Join(ErrLlcppgCheck, err)
	}
	// 3. check hash
	for name, hash := range userGenerated {
		generatedHash, ok := generated[name]
		if !ok {
			// if this file is hashable, it's unexpected
			// if not, we can skip it safely.
			if canHash(name) {
				return errors.Join(ErrLlcppgCheck, fmt.Errorf("unexpected file: %s", name))
			}
			// skip file
			continue
		}
		if !bytes.Equal(hash, generatedHash) {
			return errors.Join(ErrLlcppgCheck, fmt.Errorf("file not equal: %s", name))
		}
	}
	// 4. check missing file
	for name := range generated {
		if _, ok := userGenerated[name]; !ok {
			return errors.Join(ErrLlcppgCheck, fmt.Errorf("missing file: %s", name))
		}
	}
	return nil
}
